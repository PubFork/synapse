:sourcedir: .
:last-update-label!:
:source-highlighter: coderay
:icons: font
= Synapse
Non-intrusive signal programming library for C++11
:toclevels: 3
:toc: left
:toc-title:

[abstract]
== Abstract
(Note: Synapse is not part of Boost. Please post questions and suggestions on the Boost Developers Mailing List).

Synapse is a C++ signal programming library. It can be used to define communication channels between objects of arbitrary types in a dynamic object environment.

Synapse is non-intrusive: it allows any object of any type whatsoever to be used as a signal emitter: if two contexts in a given program happen to have access to the same object, they can use that object to communicate through Synapse signals.

== Tutorial

This is a short introduction to Synapse. There are also several complete example programs that may be of interest to the beginner.

=== Signals, emitters, receivers

In Synapse, signals are defined by function pointer typedefs. The return type is used to tell apart different signals that have otherwise identical signature.

To emit a signal, we instantiate the `emit` function template with a signal type, passing the emitter object as the first argument. The rest of the arguments follow, as defined by the signal signature.

Below we define a UI type `button` that emits a Synapse signal `clicked` (which takes no arguments) when the member function `click` is called:

[source,c++]
----
class button {

    public:

    typedef struct clicked_(*clicked)();

    void click() {
        synapse::emit<clicked>(this);
    }
};
----

To receive a signal emitted by an object, we need to connect at least one function to it. Emitting a signal calls all conected functions, in the order in which the connections were created.

Below, we connect the signal `button::clicked` to the `accept` member function of a dialog box object:

[source,c++]
----
class dialog {

    public:

    void accept();

};

....
shared_ptr<button> emitter=make_shared<button>();
shared_ptr<dialog> receiver=make_shared<dialog>();
synapse::connect<button::clicked>(emitter, receiver, &dialog::accept);
----

Or we could use a lambda instead:

[source,c++]
----
synapse::connect<button::clicked>(emitter, receiver,
    [ ](dialog & d) {
        d.accept();
    } );
----

NOTE: The `receiver` argument to `connect` is optional. If it is specified, it is passed as the first argument to the connected function, prepending all other arguments as specified by the signal signature.



=== Emitting signals from objects of 3rd-party types

In Synapse, any object whatsoever can be used as an emitter. This makes it possible to `emit` non-intrusively even if the emitter object was not designed to support signals. For example, a function that processes a file can use the standard `FILE` pointer as a Synapse emitter to report on its progress:

[source,c++]
----
typedef struct report_progress_(*report_progress)(int);

void process_file( FILE * f ) {

    for( int progress=0; !feof(f); ) {
        ....
        progress += fread(buf,1,nread,f);
        ....
        synapse::emit<report_progress>(f,progress);
    }

}
----

Outside of `process_file` the `report_progress` signal can be connected to some user interface function that updates a progress bar. Using Qt, this could look like this:

[source,c++]
----
if( FILE * f=fopen("file.dat","rb") ) {
    QProgressBar pb(....);
    auto c=synapse::connect<report_progress>(f,
        boost::bind(&QProgressBar::setValue,&pb,_1));
    process_file(f);
}
----

Notice that `process_file` is not coupled with `QProgressBar`: the `report_progress` signal could be connected to a different function or not connected at all, in which case the call to `emit` would be a no-op.

=== Managing connection lifetime

In Synapse there are two types of connection objects: <<connection,`connection`>> and <<pconnection,`pconnection`>>:

- `shared_ptr<<<connection,connection>>>` objects are returned by <<connect,`connect`>>. The user is required to keep this object afloat; the signal is disconnected when it expires.
- `weak_ptr<<<pconnection,pconnection>>>` objects are returned by <<pconnect,`pconnect`>>. The user is not required to keep this object afloat; the connection is disconnected when Synapse detects that the emitter or the receiver have expired.

NOTE: The <<release,`release`>> function can be used to convert a <<pconnection,`pconnection`>> object to a <<connection,`connection`>> object.

=== Blocking of signals

It is possible to temporarily block a specific signal for a specific emitter. This allows to dynamically disable functionality implemented by emitting signals -- without having to disconnect them.

NOTE: Blocking affects pre-existing as well as future connections.

[source,c++]
.Example
----
#include <boost/synapse/connect.hpp>
#include <boost/synapse/block.hpp>
#include <string>
#include <iostream>

namespace synapse = boost::synapse;

typedef struct print_(*print)(std::string const & s);

int main() {

    int emitter;

    weak_ptr<synapse::connection> c = synapse::connect<my_signal>(
        &emitter,
        [ ](std::string const & s) {
            std::cout << s;
        } );

    synapse::emit<print>(&emitter,"Hello World"); # <1>

    shared_ptr<synapse::blocker> b = synapse::block<print>(&emitter); # <2>
    synapse::emit<print>(&emitter,"NOOP");

    b.reset();
    synapse::emit<print>(&emitter,"Hello World"); # <3>
}
----
<1> `emit` calls the connected lambda, printing `Hello World`.

<2> The `print` signal will be blocked until `b` expires, therefore the call to `emit` on the next line is a noop, even though the `c` has not expired (meaning, the signal is still connected.)

<3> At this point `b` has expired, so the call to `emit` will call the connected lambda, printing `Hello World`, again.

=== Meta signals

Synapse features a special global emitter that emits meta signals to notify connected functions about user interactions with other signals. It can be accessed by the `meta::emitter` function.

When a `Signal` is blocked or unblocked, the meta emitter emits the `meta::blocked<Signal>` signal. Connecting this signal allows the blocked state of the signal to be automatically reflected in other systems, for example user interface.

Similarly, when a `Signal` is connected or disconnected, the meta emitter emits the ,,<<meta::connected,`meta::connected<Signal>`>>. This meta signal is useful for integrating Synapse with 3rd-party callback systems; see this example.

NOTE: To further facilitate the integration of Synapse with 3rd-partty callback systems, `connection`  objects (returned by the `connect` function) can store arbitrary user data.

=== Interthread communication


==== Emitting signals across thread boundaries

Synapse can be used to implement interthread communication using signals. The data structures created by <<connect,`connect`>> (or <<translate,`translate`>>) use thread-local storage, so by default calling <<emit,`emit`>> will call only functions connected by the calling thread (and will not return until all such functions have been called in order, or one of them throws.)

The following diagram shows the connections created (by calls to `<<connect,connect>><S>`) in a single thread for a given signal type `S`, each connecting an emitter to a function. When `<<emit,emit>><S>(e1,arg,...)` is called, all functions connected (for `S`) to the given emitter `e1` are called (in the order in which the connections were created):

image::fig1.png[]

However, it is also possible for any thread to request to receive all signals emitted by other threads, by creating its own <<thread_local_queue,`thread_local_queue`>> object using <<create_thread_local_queue,`create_thread_local_queue`>>.

In this case, _in addition_ to the behavior described above, `<<emit,emit>><S>(e1,arg,...)` will capture its arguments (depending on the signature of `S`) and queue them into the <<thread_local_queue,`thread_local_queue`>> object created by any thread _other_ than the calling thread. Each such thread must poll its own <<thread_local_queue,`thread_local_queue`>> regularly; this "emits" the queued objects locally and removes them from the queue (note that <<poll,`poll`>> is not given an emitter or a signal type, it emits locally all queued objects, regardless of signal type or emitter).

This is illustrated by the following diagram:

image::fig2.png[]

A typical use case for this system is to update user interface objects with data generated by one or multiple worker threads: the user interface objects themselves need not be thread-safe, because they will be updated only synchronously, at the time <<poll,`poll`>> is called.

IMPORTANT:  Special care must be taken to ensure that any objects referred to by arguments passed to <<emit,`emit`>> will remain valid until the time any other threads poll their <<thread_local_queue,`thread_local_queue`>> objects.

For example, the following code is incorrect in the presence of thread_local_queues:
[source,c++]
----
typedef struct my_signal_(*my_signal)( int * );

void emit_my_signal( void * emitter, int x ) {
    emit<my_signal>(emitter,&x); //Undefined behavior in the presence of thread_local_queues!
}
----

The problem is that the address of `x` may be queued into other threads' queues, and since `x` is local to `emit_my_signal`, it may be destroyed by the time these threads call <<poll,`poll`>>.

==== Scheduling function calls across thread boundaries

The <<post,`post`>> function can be used to queue into a <<thread_local_queue,`thread_local_queue`>> arbitrary functions for execution at the time <<poll,`poll`>> is called to emit queued signals. This feature allows critical worker threads to minimize the amount of time they consume by offloading expensive non-critical computations to another, non-critical thread. This also removes the need for synchronization, since the queued functions are executed synchronously in the thread that owns the <<thread_local_queue,`thread_local_queue`>> object.

== Building

Synapse has been formatted to be submitted for a Boost review, so its directory structure follows the common directory structure for Boost libraries—and it's built with Boost Build.

Alternatively, just put `connect.cpp` and either `thread_local_queue.cpp` or `interthread_stub.cpp` into your favorite build system, depending on whether or not your program calls `create_thread_local_queue`. If your program calls the `block` function, you also need to compile and link `block.cpp`.

However, note that if your program only emits signals (that is, it calls emit but it never creates any connections), there is no need to link any .cpp files; that is, `boost/synapse/emit.hpp` by itself is an independent header-only library. This way low level libraries that emit signals do not require the user to link Synapse, unless he cares to connect them.

== Portability

Synapse requires compiler support for the following C++11 features:

- thread-safe dynamic initialization of local static objects;
- `thread_local` objects;
- lambda functions
- `<thread>`
- `<atomic>`

== Synopsis

include::{sourcedir}/synopses/emit.hpp.adoc[]

include::{sourcedir}/synopses/connect.hpp.adoc[]

include::{sourcedir}/synopses/translate.hpp.adoc[]

include::{sourcedir}/synopses/connection.hpp.adoc[]

include::{sourcedir}/synopses/block.hpp.adoc[]

include::{sourcedir}/synopses/blocker.hpp.adoc[]

include::{sourcedir}/synopses/thread_local_queue.hpp.adoc[]

== Reference

[[emit]]
=== `emit`

====
[source,c++]
.#include <boost/synapse/emit.hpp>
----
namespace boost { namespace synapse {

    template <class Signal,class... A>
    int emit( void const * e, A... );

} }
----
====

Effects: ::
Calls all function objects that are connected to the specified `Signal` from the emitter `e`, in the order in which they were connected by <<connect,`connect`>>, <<pconnect,`pconnect`>> or <<translate,`translate`>>, passing the specified arguments depending on the `Signal` signature, subject to the connection lifetime/blocking restrictions.

Returns: ::
The count of the connected function objects that were called. Signals that are currently blocked are not included in the count returned by `emit`.

WARNING: It is the responsibility of the caller to ensure that the emitter object e does not expire before `emit` returns, otherwise the behavior is undefined.

Throws: ::
Any exception emitted by one of the connected function objects, in which case the remaining function objects are not called.

Notes: ::
- Values returned by the connected function objects are ignored.
- If before `emit` returns <<connect,`connect`>> is called on the same signal and the same emitter, any newly connected functions are not called during the same `emit`.
- If before `emit` returns a <<connection,`connection`>> object expires, it may or may not get called during the same `emit`.
- If `e` is `0`, `emit` simply returns `0` without calling any functions. Because of this feature, if the emitter is held by a `shared_ptr` object `sp`, there is no harm in calling `emit<Signal>(sp.get(),...)` even if `sp` is empty. Similarly, if the caller holds a `weak_ptr` to the emitter object which has expired, calling `emit<Signal>(wp.lock().get(),...)` will simply return `0`.
- `emit` takes its arguments by value. Use `boost::ref` to pass by reference.

Thread safety: ::
By default `emit` will only call functions connected from the calling thread. In addition, the signal is pushed onto any <<thread_local_queue,`thread_local_queue`>> objects created in other threads, but only if those threads currently have at least one active connection for the specified `Signal`. In this case `emit` captures its arguments similarly to `std::bind`, and it is the responsibility of the caller to ensure that they remain valid until the posted signal is processed in all other threads, by a call to <<poll,`thread_local_queue::poll`>> or <<wait,`thread_local_queue::wait`>>.

'''

[[connect]]
=== `connect`

====
[source,c++]
.#include <boost/synapse/connect.hpp>
----
namespace boost { namespace synapse {

    class connection;

    template <class Signal,class Emitter,class F>
    shared_ptr<connection> connect( <<Emitter>> e, F f ); <1>

    template <class Signal,class Emitter,class Receiver,class F>
    shared_ptr<connection> connect( <<Emitter>> e, <<Receiver>> r, F f ); <2>

} }
----
<1> `\<<Emitter>>` is either `Emitter *`, `weak_ptr<Emitter>` or, equivalently, `shared_ptr<Emitter>`.
<2> `\<<Receiver>>` by analogy.
====

The `connect` function template is used to make connections whose lifetime is explicitly managed by the user. Such connections require that the caller keeps the returned <<connection,`connection`>> object afloat for as long as the connection should persist.

Effects: ::

. Connects the specified `Signal` from the emitter `e` to the function object `f`. The arguments of `F` must match the arguments of `Signal`, except that if `r` is specified, it is prepended as the first argument to `F`, followed by the rest of the arguments as specified by the `Signal` signature. The signal is considered disconnected when either of the following occurs:
+
* The returned `shared_ptr<connection>` object expires;
* `e` (passed as either `weak_ptr<Emitter>` or `shared_ptr<Emitter>`) expires;
* `r` (passed as either `weak_ptr<Emitter>` or `shared_ptr<Emitter>`) expires.
+
NOTE: The returned `connection` object does not assume ownership of `e` or `r`: passing `shared_ptr` is equivalent to passing `weak_ptr`.
+
WARNING: If either the emitter or the receiver, passed as raw pointers, expire before the returned `connection` object has expired, the behavior is undefined.
+
.  [[meta::connected]] The `meta::emitter` emits the `meta::connected<Signal>` signal:
+
[source,c++]
----
namespace boost { namespace synapse {

    namespace meta {
            
        template <class Signal>
        struct connected {
            //unspecified
        };

        namespace connect_flags {
            unsigned const connecting=1;
            unsigned const first_for_this_emitter=2;
            unsigned const last_for_this_emitter=4;
        }

    }

} }
----
+
The `meta::connected<Signal>` signal is also emitted when the returned <<connection,`connection`>> object expires. Handlers of the meta signal take a mutable reference to the <<connection,`connection`>> object being created or destroyed, and a second `unsigned` argument, `flags`, which indicates the circumstances under which the meta signal is emitted:

* If the <<connection,`connection`>> object is being created, the `connecting` bit is set, otherwise it is clear;
* If this is the first `Signal` connection being created for the emitter `e`, the `first_for_this_emitter` bit is set, otherwise it is clear;
* If this is the last `Signal` connection being destroyed for the emitter `e`, the `last_for_this_emitter` bit is set, otherwise it is clear.
+
NOTE: The passed <<connection,`connection`>> object can be used to access the emitter and receiver objects passed to `connect`.

Thread safety: ::
Please see <<emit,`emit`>> and <<thread_local_queue,`thread_local_queue`>>.

'''

[[translate]]
=== `translate`

====
[source,c++]
.#include <boost/synapse/translate.hpp>
----
namespace boost { namespace synapse {

    class connection;

    template <
        class OriginalSignal, class TranslatedSignal,
        class OriginalEmitter,class TranslatedEmitter>
    shared_ptr<connection> translate( <<OriginalEmitter>> e1, <<TranslatedEmitter>> e2 ); <1>

} }
----
<1> `\<<OriginalEmitter>>` is `OriginalEmitter *`, `weak_ptr<OriginalEmitter>` or, equivalently, `shared_ptr<OrignialEmitter>`; `\<<TranslatedEmitter>>` by analogy.
====

Effects: ::
The `translate` function template creates a connection which causes the emitter `e2` to emit `TranslatedSignal` each time the emitter `e1` emits `OriginalSignal` (the two signals must have campatible signatures). This behavior persists until:

- the returned <<connection,`connection`>> object expires;
- `e1` (passed as either `weak_ptr` or `shared_ptr` expires;
- `e2` (passed as either `weak_ptr` or `shared_ptr` expires.

NOTE: The returned <<connection,`connection`>> object does not assume ownership of `e1` or `e2`: passing `shared_ptr` is equivalent to passing `weak_ptr`.

WARNING: If either `e1` or `e2`, passed as raw pointers, expire before the returned <<connection,`connection`>> object has expired, the behavior is undefined.

'''

[[connection]]
=== `connection`

====
[source,c++]
.#include <boost/synapse/connection.hpp>
----
namespace boost { namespace synapse {

    class connection { //abstract base

    protected:

        connection();
        ~connection();

    public:
        
        template <class T>
        void set_user_data( T const & );

        template <class T>
        T * get_user_data() const;

        template <class T>
        shared_ptr<T> emitter() const;

        template <class T>
        shared_ptr<T> receiver() const;
    };

} }
----
====

The <<connect,`connect`>> and <<translate,`translate`>> functions return `shared_ptr<connection>` that is used to control the lifetime of the connection. As well, `connection` objects are passed to handlers of the <<meta::connected,`meta::connected`>> signal, which can use the <<connection::emitter,`emitter`>> member function template to access the emitter object passed to <<connect,`connect`>>/<<translate,`translate`>>, and the <<connection::set_user_data,`set_user_data`>>/<<connection::get_user_data,`get_user_data`>> member function templates to store auxiliary information in the <<connection,`connection`>> object.

'''

[[connection::set_user_data]]
==== `set_user_data`

[source,c++]
----
template <class T>
void set_user_data( shared_ptr<T> const & data );
----

Description: ::
Stores a copy of data into this. Use `get_user_data` to access it.

'''

[[connection::get_user_data]]
==== `get_user_data`

[source,c++]
----
template <class T>
T * get_user_data() const;
----

Returns: ::
* If this contains object of type T previously copied by a call to connection::set_user_data, returns a pointer to the copy.
* If connection::set_user_data has not been called for this, or if the type used to instantiate the connection::set_user_data function template doesn't match the type used with connection::get_user_data, returns 0.

'''

[[connection::emitter]]
==== `emitter`

[source,c++]
----
template <class T>
shared_ptr<T> emitter() const;
----

Returns: ::
A shared_ptr that points the emitter that was passed to an overload of the connect (or translate) function template to get the connection object.

Notes: ::

* An empty `shared_ptr` is returned if:
** `T` does not match the static type of the emitter passed to `connect` (or `translate`), or
** the emitter was passed to `connect` (or `translate`) as a `shared_ptr`/`weak_ptr` and it has expired.
* If the emitter was passed to `connect` (or `translate`) as a raw pointer, the returned `shared_ptr` points that emitter but does not (can not) keep it afloat.

'''

[[connection::receiver]]
==== `receiver`

[source,c++]
----
template <class T>
shared_ptr<T> receiver() const;
----

Returns: ::
A `shared_ptr` that points the receiver that was passed to an overload of the `connect` (or `translate`) function template to get the `connection` object.

Notes: ::

* An empty `shared_ptr` is returned if:
** No receiver object was passed to `connect` (or `translate`), or
** `T` does not match the static type of the receiver passed to `connect` (or `translate`), or
** the emitter was passed to `connect` (or `translate`) as a `shared_ptr`/`weak_ptr` and it has expired.
* If the emitter was passed to `connect` (or `translate`) as a raw pointer, the returned `shared_ptr` points that emitter but does not (can not) keep it afloat.

'''

[[pconnect]]
=== `pconnect`

====
[source,c++]
.#include <boost/synapse/connect.hpp>
----
namespace boost { namespace synapse {

    class pconnection;

    template <class Signal,class Emitter,class F>
    weak_ptr<pconnection> pconnect( <<Emitter>> e, F f ); <1>

    template <class Signal,class Emitter,class Receiver,class F>
    weak_ptr<pconnection> pconnect( <<Emitter>> e, <<Receiver>> r, F f ); <2>

} }
----
<1> `\<<Emitter>>` is `weak_ptr<Emitter>` or, equivalently, `shared_ptr<Emitter>`.
<2> `\<<Receiver>>` by analogy.
====

The `pconnect` function template is used to create _persistent_ connections. Unlike connections with explicitly managed lifetime (see <<connect,`connect`>>), the caller of `pconnect` is not required to keep the returned object afloat; instead, the <<pconnection,`pconnection`>> is automatically persisted until `e` (or `r`, if used) expire. The `pconnect` function has the limitation that `e` and `r` are required to be `weak`/`shared_ptr`, while <<connect,`connect`>> can be used with raw pointers as well.

NOTE: A <<pconnection,`pconnection`>> can be converted to <<connection,`connection`>> by calling <<release,`release`>>.

Effects: ::

. Connects the specified `Signal` from the emitter `e` to the function object `f`. The arguments of `F` must match the arguments of `Signal`, except that if `r` is specified, it is prepended as the first argument to `F`, followed by the rest of the arguments as specified by the `Signal` signature. The signal is considered disconnected when either `e` or `r` (if used) expire.
+
. The <<meta::connected,`meta::connected<Signal>`>> effects are identical to <<connect,`connect`>>.

Thread safety: ::
Please see <<emit,`emit`>> and <<thread_local_queue,`thread_local_queue`>>.

'''

[[ptranslate]]
=== `ptranslate`

====
[source,c++]
.#include <boost/synapse/translate.hpp>
----
namespace boost { namespace synapse {

    class pconnection;

    template <
        class OriginalSignal, class TranslatedSignal,
        class OriginalEmitter,class TranslatedEmitter>
    weak_ptr<pconnection> ptranslate( <<OriginalEmitter>> e1, <<TranslatedEmitter>> e2 ); <1>

} }
----
<1> `\<<OriginalEmitter>>` is either `weak_ptr<OriginalEmitter>` or, equivalently, `shared_ptr<OrignialEmitter>`; `\<<TranslatedEmitter>>` by analogy.
====

Effects: ::
The `ptranslate` function template creates a _persistent_ connection which causes the emitter `e2` to emit `TranslatedSignal` each time the emitter `e1` emits `OriginalSignal` (the two signals must have campatible signatures). Unlike connections with explicitly managed lifetime (see <<translate,`translate`>>, the caller of `ptranslate` is not required to keep the returned object afloat; instead, the <<pconnection,`pconnection`>> is automatically persisted until either `e1` or `e2` expire. The `ptranslate` function has the limitation that `e1` and `e2` are erquired to be `weak'/`shared_ptr`, while <<translate,`translate`>> can be used with raw pointers as well.

NOTE: A <<pconnection,`pconnection`>> can be converted to <<connection,`connection`>> by calling <<release,`release`>>.

'''

[[pconnection]]
=== `pconnection`

====
[source,c++]
.#include <boost/synapse/connection.hpp>
----
namespace boost { namespace synapse {

    class pconnection: protected connection { //abstract base

    protected:

        pconnection();
        ~pconnection();

    public:
        
        using connection::set_user_data;
        using connection::get_user_data;
        using connection::emitter;
        using connection::receiver;

    };

} }
----
====

The <<pconnect,`pconnect`>> and <<ptranslate,`ptranslate`>> functions return `weak_ptr<pconnection>` that is used as a non-owning reference to the created connection object. Objects of type `pconnection` are passed to handlers of the <<meta::connected,`meta::connected`>> signal as a <<connection,`connection`>> reference.

NOTE: Use <<release,`release`>> to convert a non-owning `weak_ptr<pconnection>` reference to an owning `shared_ptr<<<connection,connection>>>` reference.

'''

[[block]]
=== `block`

====
[source,c++]
.#include <boost/synapse/block.hpp>
----
namespace boost { namespace synapse {

    class blocker;

    template <class Signal,class Emitter>
    shared_ptr<blocker> block( <<Emitter>> e ); <1>

} }
----
<1> `\<<Emitter>>` is either `Emitter *`, `weak_ptr<Emitter>` or, equivalently, `shared_ptr<Emitter>`.
====

Effects: ::
. Blocks the specified `Signal` from the emitter `e` until the returned `blocker` object expires. While the `Signal` is blocked, calls to `emit<Signal>` for `e` are ignored and return `0`. The returned `blocker` object does not own `e` even if the `shared_ptr` `block` overload is used.
. [[meta::blocked]] The `meta::emitter` emits the `meta::blocked<Signal>`:
+
[source,c++]
----
namespace boost { namespace synapse { namespace meta {

    template <class Signal>
    struct blocked {
        //unspecified
    };
        
} } }
----
The `meta::blocked<Signal>` signal is also emitted when the returned <<blocker,`blocker`>> object expires. Handlers of the meta signal take a reference to the <<blocker,`blocker`>> object being created or destroyed, and a second `bool` argument, `is_blocked`, which is true if the signal is becoming blocked, false if it is becoming unblocked.

NOTE: Blocking affects existing as well as future connections.

WARNING: If `block` is passed a raw pointer, deleting the emitter before the returned `blocker` object has expired results in undefined behavior.

'''

[[blocker]]
=== `blocker`

====
include::{sourcedir}/synopses/blocker.hpp.adoc[]
====

The <<block,`block`>> function returns `shared_ptr<blocker const>` that is used to control the time the signal remains blocked. As well, `blocker` objects are passed to handlers of the <<meta::blocked,`meta::blocked`>> signal, which can use the `emitter` member function template to access the emitter object passed to <<block,`block`>>.

'''

[[blocker::emitter]]
==== `emitter`

[source,c++]
----
template <class T>
shared_ptr<T> emitter() const;
----

Returns: ::
A `shared_ptr` that points the emitter that was passed to an overload of the <<block,`block`>> function template to get the `blocker` object.

Notes: ::
* An empty shared_ptr is returned if:
** `T` does not match the static type of the emitter passed to <<block,`block`>>, or
** the emitter was passed to <<block,`block`>> as a `shared`/`weak_ptr` and it has expired.
* If the emitter was passed to <<block,`block`>> as a raw pointer, the returned `shared_ptr` points that emitter but does not (can not) keep it afloat.

'''

[[thread_local_queue]]
=== `thread_local_queue`

[[create_thread_local_queue]]
==== `create_thread_local_queue`

====
[source,c++]
.#include <boost/synapse/thread_local_queue.hpp>
----
namespace boost { namespace synapse {

    struct thread_local_queue;
    shared_ptr<thread_local_queue> create_thread_local_queue();

} }
----
====

Returns: ::
A thread-local object that can be used to queue signals emitted asynchronously from other threads. Use <<poll,`poll`>> to emit the queued signals synchronously into the calling thread. See <<Interthread communication>>.

NOTE: While any number of threads can use this function to create their own <<thread_local_queue,`thread_local_queue`>>, it is invalid to create more than one `thread_local_queue` object per thread.

'''

[[poll]]
==== `poll`

====
[source,c++]
.#include <boost/synapse/thread_local_queue.hpp>
----
namespace boost { namespace synapse {

    int poll( thread_local_queue & );

} }
----
====

Effects: ::
Synchronously emits all signals queued asynchronously into `q` by calls to <<emit,`emit`>> from other threads. See <<Interthread communication>>.

Returns: ::
The total number of signals emitted.

'''

[[wait]]
==== `wait`

====
[source,c++]
.#include <boost/synapse/thread_local_queue.hpp>
----
namespace boost { namespace synapse {

    int wait( thread_local_queue & );

} }
----
====

Effects: ::
The same as `<<poll,poll>>(q)`, except that it blocks and does not return until at least one signal was delivered.

Returns: ::
The total number of signals emitted (always greater than 1).

'''

[[post]]
==== `post`

====
[source,c++]
.#include <boost/synapse/thread_local_queue.hpp>
----
namespace boost { namespace synapse {

    void post( thread_local_queue &, function<void()> const & );

} }
----
====

Effects: ::
Queues `f` to be called next time `q` is polled; that is, `f` will be executed synchronously in the thread that has created `q`.

NOTE: While <<poll,`poll`>> (or <<wait,`wait`>>) must be called from the thread that created the <<thread_local_queue,`thread_local_queue`>> object, <<post,`post`>> may be called from any thread. 

== Programming techniques

== Examples

include::{sourcedir}/examples/glfw.adoc[]

== Q&A

[qanda]
How does Synapse differ from Boost Signals 2, which is also "non-intrusive"?::
    The main design difference is that in Boost Signals 2 emitting a signal requires a signal object. This is significant because in general it is not trivial to associate a Boost Signals 2 signal object with 3rd-party objects. When using Synapse such association is not necessary because the 3rd-party object itself can be passed to `emit`.
What is the design rationale for ignoring the value returned by connected functions?::
    A typical use case for Synapse is when the caller of `emit` doesn't care if there are 0, 1 or many connected functions. Allowing return values makes the zero/many case quite tricky to deal with. On the other hand, passing a reference or a pointer to `emit` to return/accumulate values from any number of connected functions (if needed) is simpler and fits that case nicely.
Is there a way to stop the emit loop before all connected functions have been called?::
    No, except by throwing an exception.
I am concerned about code size, does Synapse use a lot of templates?::
    Yes, there are templates instantiated for each signal type. This is done so that the dispatch by signal type occurs at compile-time, leaving only emitter dispatch at run-time. However, static types are erased as soon as possible, so template bloat is kept to a minimum.
I do not need thread-safety, is there a way to configure Synapse to eliminate thread safety overhead?::
    Most data structures in Synapse are not thread-safe, instead they are thread-local. The overhead of using the library across multiple threads is contained only in `thread_local_queue.cpp`, which is an optional component.
